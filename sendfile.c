#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>
#include <time.h>
#include <sys/time.h>
#include <assert.h>
#include <unistd.h>     /* for pause */
#include <signal.h>     /* for signal */
#include "packet.h"
#include "md5.h" 



#define ALPHA 0.5  
#define SEQ_LENGTH 50000
#define PCK_ROUND 10 /* number of packets sent per rounds */

/* using queue to handle the sequence of each timeout */
typedef struct {
        int first;                      /* position of first element */
        int last;                       /* position of last element */
        int count;                      /* number of queue elements */
	int q[100];			/* the body of queue */
} queue;
#include "queue.h"


struct alarm_time{
int is_set;
int tv_sec;
int tv_usec;
int duration;
};
struct alarm_time alarm_list[SEQ_LENGTH];
#include "alarm.h"

char** str_split(char* a_str, const char a_delim);
void handle_alarm();

/* using queue to handle the sequence of each timeout */
queue* signal_queue;


int la_seq;		/* the least acknowledge sequence number */
int ns_seq;		/* the sequence number to be sent next */
int total_packets; /* the total number of data packets to be sent */


int seq[SEQ_LENGTH];	/* array of sequence number */
int retrans_signal[SEQ_LENGTH];/* array that indicate packet retrasmission */
char* retrans_buffer[SEQ_LENGTH];/* buffer that hold the packet to be retransmitted */


int main(int argc, char** argv)
{
	struct sockaddr_in sin; 
	int sock, i, slen=sizeof(sin);
	char buf[BUFLEN];	/* message buffer */
	char *file_buf, *packet;
	int recvlen;		/* # bytes in acknowledgement message */
	int rtt;		/* round trip time in millisecond */
	int count_last_packet = 0; /* count the number of retransmission the last packet. if >100, consider the server ends*/
	struct timeval tv;
	//struct hostent *host = gethostbyname(argv[1]);
	
	signal_queue = (queue*)malloc(sizeof(queue)); /* initial queue for timeout signal generated by each transmission */
	
	char** token = str_split(argv[2],':');
	printf("%s\n",token[0]);
	printf("%s\n",token[1]);
	//struct hostent *host = gethostbyname(token[0]);
	char* file_name = argv[4];	
	
	
	/* 0: not used
	 * 1: being transmitted, waiting for ack
	 * 2: ack received
	 */
	for(i=0;i<SEQ_LENGTH;i++){
		seq[i] = 0;
	}
	/* 0: no need to retransmission  
	 * 1: need retransmission
	 */
	for(i=0;i<SEQ_LENGTH;i++){
		retrans_signal[i] = 0;
	}
	//unsigned int server_addr = *(unsigned int *) host->h_addr_list[0];
	
	/* get the ip address of the server
	char* address;
	address = argv[2];
	int length = 0;
	while(*address != ':'){
		length++;
		address++;
	}
	char *ip_address = (char*)malloc(sizeof(char)*length + 1);
	memcpy(ip_address, argv[2], sizeof(char)*length);
	ip_address[length] = '\0';
	printf("%s\n",ip_address);
	*/	


	/* server port number */
	unsigned short server_port = atoi (token[1]);
	
	/* create a socket */

	if ((sock=socket(AF_INET, SOCK_DGRAM, 0))==-1)
		printf("socket created\n");

	/* bind it to the server addresses and use the given port number */
	memset((char *)&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	//sin.sin_addr.s_addr = server_addr;
	sin.sin_addr.s_addr = inet_addr(token[0]);
	sin.sin_port = htons(server_port);
	
	FILE *fp = fopen(file_name, "r");
	/* get the size of the file */
	fseek(fp,0l,SEEK_END);
	int file_size = ftell(fp);
	total_packets = file_size/BUFLEN+1;
	rewind(fp);
	//printf("The file size is %d\n",file_size);
			

	/* initial packet*/
	packet = (char*)malloc(PCKSIZE*sizeof(char)); 
	gettimeofday(&tv,NULL);
	/* send a ping-pong message to get the rtt */
	*(short *) (packet+16) = (short) htons(-1); /* -1 means it is a ping packet*/
	*(int *) (packet+18) = (int) htonl(tv.tv_sec);
	*(int *) (packet+22) = (int) htonl(tv.tv_usec);
	*(int *) (packet+26) = (int) htonl(file_size);

	md5((uint8_t *) (packet+16), 14, (uint8_t *) packet);
	

	printf("sending ping pong packet\n");
	if (sendto(sock, packet, 30, 0, (struct sockaddr *)&sin, slen)==-1) {
		perror("ping packet sending failure\n");
		exit(1);
	}
	/* set timeout for ping pong packet */	
	tv.tv_sec = 0;
	tv.tv_usec = 5000;
	if(setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv))<0){
		printf("socket option  SO_RCVTIMEO not support\n");
			return;
	}
	/* now receive a pong packet from the server */
	while(1) {
	recvlen = recvfrom(sock, buf, BUFLEN, 0, (struct sockaddr *)&sin, &slen);
	if(recvlen < 0) { /* timeout occurs, trigger a retransmission */
		packet = (char*)malloc(PCKSIZE*sizeof(char)); 
		gettimeofday(&tv,NULL);
		/* send a ping-pong message to get the rtt */
		*(short *) (packet+16) = (short) htons(-1); /* -1 means it is a ping packet*/
		*(int *) (packet+18) = (int) htonl(tv.tv_sec);
		*(int *) (packet+22) = (int) htonl(tv.tv_usec);
		*(int *) (packet+26) = (int) htonl(file_size);

		md5((uint8_t *) (packet+16), 14, (uint8_t *) packet);
		if (sendto(sock, packet, 30, 0, (struct sockaddr *)&sin, slen)==-1) {
			perror("ping packet sending failure\n");
			exit(1);
		}
	}
	else if (recvlen >= 0) {
	/* check the correctness of the packet using md5 */
		
		uint8_t result[16];
		md5((uint8_t *)(buf+16), recvlen-16, result);	
		if (!packetCorrect((uint8_t *)buf, result)) {
			printf("[recv corrupt packet]\n");
			continue;
		}
		
        	buf[recvlen] = 0;	/* expect a printable string - terminate it */
		int tv_sec, tv_usec;
		tv_sec =  (int)ntohl(*(int *)(buf+2));
		tv_usec = (int)ntohl(*(int *)(buf+6));
		
		gettimeofday(&tv,NULL);
        	//rtt = 1000000*(tv.tv_sec - tv_sec) + (tv.tv_usec-tv_usec);
		rtt = 5000;
		break;
	}
	}
 
	/* read file to a buffer with BUFLEN length and send it to the sever continuously*/
	packet = (char*)malloc(PCKSIZE*sizeof(char));
	file_buf = (char*)malloc(BUFLEN*sizeof(char));
	if (fp != NULL) {

	    i = 0;
	    la_seq = ns_seq = 0;
	/* send PCK_ROUND number of packets at the first round */ 
	    while(i<PCK_ROUND) {
		file_buf = (char*)malloc(BUFLEN*sizeof(char));
		size_t newLen = fread(file_buf, sizeof(char), BUFLEN, fp);
	    	if (newLen == 0) {
			break;	    	
		}
	    	else {
        		file_buf[++newLen] = '\0'; /* Just to be safe. */
			printf("[sending data %d] start (%d)\n",ns_seq,(int)newLen);
			gettimeofday(&tv,NULL);
			/* create the ftp packet */
			*(short *) (packet+16) = (short) htons(1); /* 1 means it is a ftp packet */
			*(int *) (packet+18) = (int) htonl(tv.tv_sec);
			*(int *) (packet+22) = (int) htonl(tv.tv_usec);
			*(short *) (packet+26) = (short) htons(ns_seq);
			strcpy(packet+28,file_buf);

			int pck_size =16+12+strlen(file_buf);
			md5((uint8_t *) (packet+16), pck_size-16, (uint8_t *) packet);
			
			if (sendto(sock, packet, pck_size, 0, (struct sockaddr *)&sin, slen) ==-1) {
				perror("buffer sending failure\n");
				exit(1);
			}
			set_alarm(ns_seq,1.5*rtt);
			seq[ns_seq] = 1;
			/* store the buffer for retransmission */
			retrans_buffer[ns_seq] = (char*)malloc(BUFLEN*sizeof(char));
			strcpy(retrans_buffer[ns_seq],file_buf);
			ns_seq++;
			free(file_buf);
    	    	}
		i++; 
	    }
	    while(1) {
		
		check_expire(); /* check whether there are alarm expired */
		if( checkFinish() == 1 ) break;
		/* if >100, consider the server ends*/
		if(count_last_packet > 100) break;		

		/*  Keep waiting for acknowledgements from the server */
		/*  Make the recvfrom non blocking to receive latter acknowledgements */
		recvlen = recvfrom(sock, packet, PCKSIZE, MSG_DONTWAIT, (struct sockaddr *)&sin, &slen);
                if (recvlen >= 0) {
			
			/* check the correctness of the packet using md5 */
			uint8_t result[16];
			md5((uint8_t *)(packet+16), recvlen-16, result);	
			if (!packetCorrect((uint8_t *)packet, result)) {
				printf("[recv corrupt packet]\n");
				continue;
			}

                        packet[recvlen] = 0;
			short ack_num = (short) ntohs(*(short *)(packet+16));
			/* The ack_num should be greater or equal to zero */
			/* Ignore the packet that has already arrived */
			if(ack_num < 0 || seq[ack_num] == 2) { 
				continue;
			}
						
			seq[ack_num] = 2; /* sequence number is acknowledged */

			/* update the rtt based on the new rtt */
			int tv_sec, tv_usec;
			tv_sec =  (int)ntohl(*(int *)(packet+18));
			tv_usec = (int)ntohl(*(int *)(packet+22));
			
			gettimeofday(&tv,NULL);
			int newRtt = 1000000*(tv.tv_sec - tv_sec) + (tv.tv_usec-tv_usec);
			//rtt = ALPHA*rtt + (1-ALPHA)*newRtt;
			//rtt = newRtt;
			rtt = 5000;
			
			int count=0;
			if(ack_num == la_seq) { 
				i = la_seq;
				while(seq[i] == 2) {
					seq[i++] = 0; /*sliding windows moving right*/
					count++;
				}
			la_seq = la_seq+count;
			}
		        /* multiple packets accumulated to be sent */
			while(count != 0) {
				file_buf = (char*)malloc(BUFLEN*sizeof(char));
				size_t newLen = fread(file_buf, sizeof(char), BUFLEN, fp);
	    			if (newLen == 0) {
					break;	    	
				}
	    			else {
		        		file_buf[++newLen] = '\0'; /* Just to be safe. */
					//printf("The buffer contains:\n");
					//printf("%s\n",file_buf);				

					printf("[sending data %d] start (%d)\n",ns_seq,(int)newLen);
					
					gettimeofday(&tv,NULL);
					/* create the ftp packet */
					*(short *) (packet+16) = (short) htons(1); /* 1 means it is a ftp packet */
					*(int *) (packet+18) = (int) htonl(tv.tv_sec);
					*(int *) (packet+22) = (int) htonl(tv.tv_usec);
					*(short *) (packet+26) = (short) htons(ns_seq);
					strcpy(packet+28,file_buf);

					int pck_size =16+12+strlen(file_buf);
					md5((uint8_t *) (packet+16), pck_size-16, (uint8_t *) packet);
					
					if (sendto(sock, packet, pck_size, 0, (struct sockaddr *)&sin, slen) ==-1) {
						perror("buffer sending failure\n");
						exit(1);
					}
					seq[ns_seq] = 1;
					set_alarm(ns_seq,1.5*rtt);
					/* store the buffer for retransmission */
					retrans_buffer[ns_seq] = malloc(BUFLEN*sizeof(char));
					strcpy(retrans_buffer[ns_seq],file_buf);
					ns_seq++;
					count--;
					free(file_buf);
    	    			}
			}
                } // end of transmit new file
		/* check for transmission packets */
		for(i=la_seq;i<ns_seq;i++) {			
			if(retrans_signal[i] == 1 && seq[i] == 1) {
				
				if(i == total_packets-1)
					count_last_packet++;
				retrans_signal[i] = 0;
				gettimeofday(&tv,NULL);
				/* create the ftp packet */
				packet = (char*)malloc(PCKSIZE*sizeof(char)); 
				*(short *) (packet+16) = (short) htons(1); /* 1 means it is a ftp packet */
				*(int *) (packet+18) = (int) htonl(tv.tv_sec);
				*(int *) (packet+22) = (int) htonl(tv.tv_usec);
				*(short *) (packet+26) = (short) htons(i);
				strcpy(packet+28,retrans_buffer[i]);

				printf("[retransmitting data %d] start (%d)\n",i,(int)strlen(retrans_buffer[i]));
				int pck_size = 16+12+strlen(retrans_buffer[i]);
				md5((uint8_t *) (packet+16), pck_size-16, (uint8_t *) packet);
				if (sendto(sock, packet, pck_size, 0, (struct sockaddr *)&sin, slen) ==-1) {
					perror("buffer sending failure\n");
					exit(1);
				}
				set_alarm(i,1.5*rtt);
				//seq[i] = 1;
			}
		}		
	    }
	    fclose(fp);
	}
	close(sock);
	exit(0);
}

/* id is the sequence number of a packet and duration is the length of the timeout */
void set_alarm (int id, int duration) {
	struct timeval tv;
 	gettimeofday(&tv,NULL);
 	alarm_list[id].is_set = 1;
 	alarm_list[id].tv_sec = tv.tv_sec;
 	alarm_list[id].tv_usec = tv.tv_usec;
 	alarm_list[id].duration = duration;
}

/* iterate through all the packets being transmitted and check for timeout expires */
void check_expire() {
 	int i;
 	struct timeval tv; 
	/* go through all the possible sequence number */
 	for(i=la_seq;i<ns_seq;i++) {
	  if(alarm_list[i].is_set == 1) {	
		gettimeofday(&tv,NULL);
		int elapsed_time = (tv.tv_sec-alarm_list[i].tv_sec)*1000000+(tv.tv_usec - alarm_list[i].tv_usec);
		//printf("elapsed time is %d\n", elapsed_time);
		if( elapsed_time > alarm_list[i].duration) {
			alarm_list[i].is_set= 0;
	   		handle_alarm(i);
		}
  	   }
 	}
}

void handle_alarm(int seq_num) {
	/* if the acknowledge is not received, perform a retransmission */
	if(seq[seq_num] == 1){
		/* set flag to indicate packet retransmission*/
		retrans_signal[seq_num] = 1;
	}
	printf("[handling alarm]\n");
}

int checkFinish(){
	int i;
	for(i=0;i<total_packets;i++) {
		if(seq[i] == 1) {
//			printf("sequence number %d not received\n",i);	
			return 0;
		}
	}
	return 1;
}

char** str_split(char* a_str, const char a_delim)
{
    char** result    = 0;
    size_t count     = 0;
    char* tmp        = a_str;
    char* last_comma = 0;
    char delim[2];
    delim[0] = a_delim;
    delim[1] = 0;

    /* Count how many elements will be extracted. */
    while (*tmp)
    {
        if (a_delim == *tmp)
        {
            count++;
            last_comma = tmp;
        }
        tmp++;
    }

    /* Add space for trailing token. */
    count += last_comma < (a_str + strlen(a_str) - 1);

    /* Add space for terminating null string so caller
       knows where the list of returned strings ends. */
    count++;

    result = malloc(sizeof(char*) * count);

    if (result)
    {
        size_t idx  = 0;
        char* token = strtok(a_str, delim);

        while (token)
        {
            assert(idx < count);
            *(result + idx++) = strdup(token);
            token = strtok(0, delim);
        }
        assert(idx == count - 1);
        *(result + idx) = 0;
    }

    return result;
}
//./sendfile -r 128.42.208.5:18000 -f usa.txt